import { Injectable } from '@nestjs/common';
import { exec } from 'child_process';
import { promisify } from 'util';
import * as https from 'https';
import * as http from 'http';

const execAsync = promisify(exec);

export interface VulnerabilityReport {
  target: string;
  timestamp: string;
  riskLevel: 'low' | 'medium' | 'high' | 'critical';
  overallScore: number; // 0-100

  // Scan nmap
  openPorts: {
    port: number;
    service: string;
    version?: string;
    risk: 'low' | 'medium' | 'high';
  }[];

  // Technologies d√©tect√©es
  technologies: {
    name: string;
    version?: string;
    category: string;
  }[];

  // Vuln√©rabilit√©s d√©tect√©es
  vulnerabilities: {
    id: string;
    title: string;
    severity: 'low' | 'medium' | 'high' | 'critical';
    description: string;
    recommendation: string;
    cve?: string;
  }[];

  // Headers de s√©curit√©
  securityHeaders: {
    present: string[];
    missing: string[];
    score: number;
  };

  // SSL/TLS
  ssl: {
    enabled: boolean;
    version?: string;
    issuer?: string;
    validUntil?: string;
    issues: string[];
  };

  // Recommandations
  recommendations: string[];
}

@Injectable()
export class VulnerabilityScannerService {
  async scanTarget(target: string): Promise<VulnerabilityReport> {
    console.log(`[VULN SCANNER] Starting comprehensive scan of ${target}`);

    const report: VulnerabilityReport = {
      target,
      timestamp: new Date().toISOString(),
      riskLevel: 'medium',
      overallScore: 70,
      openPorts: [],
      technologies: [],
      vulnerabilities: [],
      securityHeaders: {
        present: [],
        missing: [],
        score: 0,
      },
      ssl: {
        enabled: false,
        issues: [],
      },
      recommendations: [],
    };

    try {
      // 1. Scan nmap des ports
      await this.scanPorts(target, report);

      // 2. Analyse HTTP/HTTPS
      await this.analyzeHTTP(target, report);

      // 3. D√©tection des technologies
      await this.detectTechnologies(target, report);

      // 4. V√©rification SSL/TLS
      await this.checkSSL(target, report);

      // 5. Analyse des vuln√©rabilit√©s communes
      await this.checkCommonVulnerabilities(report);

      // 6. Calcul du score global et niveau de risque
      this.calculateRiskLevel(report);

      // 7. G√©n√©ration des recommandations
      this.generateRecommendations(report);

    } catch (error) {
      console.error(`[VULN SCANNER] Error:`, error);
      report.vulnerabilities.push({
        id: 'SCAN_ERROR',
        title: 'Erreur lors du scan',
        severity: 'medium',
        description: `Erreur: ${error.message}`,
        recommendation: 'V√©rifier la cible et r√©essayer',
      });
    }

    return report;
  }

  private async scanPorts(target: string, report: VulnerabilityReport): Promise<void> {
    try {
      console.log(`[VULN SCANNER] Scanning ports...`);

      // Extraire le domaine/IP de l'URL
      const hostname = this.extractHostname(target);

      const { stdout } = await execAsync(`nmap -sV -F -T4 ${hostname}`, {
        timeout: 60000,
      });

      const portRegex = /(\d+)\/(tcp|udp)\s+open\s+(\S+)\s*(.*)?/gi;
      let match;

      while ((match = portRegex.exec(stdout)) !== null) {
        const port = parseInt(match[1]);
        const service = match[3] || 'unknown';
        const version = match[4] ? match[4].trim() : undefined;

        // √âvaluer le risque du port
        let risk: 'low' | 'medium' | 'high' = 'low';
        if ([21, 23, 25, 3306, 3389, 5432].includes(port)) {
          risk = 'high'; // Ports sensibles
        } else if ([22, 443, 3000, 8080].includes(port)) {
          risk = 'medium';
        }

        report.openPorts.push({ port, service, version, risk });
      }

      console.log(`[VULN SCANNER] Found ${report.openPorts.length} open ports`);
    } catch (error) {
      console.warn(`[VULN SCANNER] Port scan failed:`, error.message);
    }
  }

  private async analyzeHTTP(target: string, report: VulnerabilityReport): Promise<void> {
    try {
      console.log(`[VULN SCANNER] Analyzing HTTP headers...`);

      const url = target.startsWith('http') ? target : `https://${target}`;
      const headers = await this.fetchHeaders(url);

      // Headers de s√©curit√© √† v√©rifier
      const securityHeaders = {
        'strict-transport-security': 'HSTS',
        'x-frame-options': 'X-Frame-Options',
        'x-content-type-options': 'X-Content-Type-Options',
        'x-xss-protection': 'X-XSS-Protection',
        'content-security-policy': 'CSP',
        'referrer-policy': 'Referrer-Policy',
        'permissions-policy': 'Permissions-Policy',
      };

      for (const [header, name] of Object.entries(securityHeaders)) {
        if (headers[header]) {
          report.securityHeaders.present.push(name);
        } else {
          report.securityHeaders.missing.push(name);

          // Ajouter une vuln√©rabilit√© pour les headers critiques manquants
          if (['strict-transport-security', 'x-frame-options', 'content-security-policy'].includes(header)) {
            report.vulnerabilities.push({
              id: `MISSING_${header.toUpperCase()}`,
              title: `Header de s√©curit√© manquant: ${name}`,
              severity: 'medium',
              description: `Le header ${name} n'est pas pr√©sent, exposant √† des risques de s√©curit√©.`,
              recommendation: `Ajouter le header ${name} dans la configuration du serveur.`,
            });
          }
        }
      }

      report.securityHeaders.score = Math.round(
        (report.securityHeaders.present.length / Object.keys(securityHeaders).length) * 100
      );

      // D√©tecter le serveur web
      if (headers['server']) {
        report.technologies.push({
          name: headers['server'],
          category: 'Web Server',
        });

        // V√©rifier si la version est expos√©e (mauvaise pratique)
        if (/\d+\.\d+/.test(headers['server'])) {
          report.vulnerabilities.push({
            id: 'SERVER_VERSION_DISCLOSURE',
            title: 'Version du serveur expos√©e',
            severity: 'low',
            description: 'Le header Server r√©v√®le la version exacte du serveur web.',
            recommendation: 'Masquer la version du serveur dans la configuration.',
          });
        }
      }

      console.log(`[VULN SCANNER] Security headers score: ${report.securityHeaders.score}%`);
    } catch (error) {
      console.warn(`[VULN SCANNER] HTTP analysis failed:`, error.message);
    }
  }

  private async detectTechnologies(target: string, report: VulnerabilityReport): Promise<void> {
    try {
      console.log(`[VULN SCANNER] Detecting technologies...`);

      const url = target.startsWith('http') ? target : `https://${target}`;
      const { body, headers } = await this.fetchPage(url);

      // D√©tection bas√©e sur les headers
      if (headers['x-powered-by']) {
        report.technologies.push({
          name: headers['x-powered-by'],
          category: 'Framework',
        });
      }

      // D√©tection dans le HTML
      const techPatterns = {
        'WordPress': /<meta name="generator" content="WordPress/i,
        'React': /react/i,
        'Vue.js': /vue\.js/i,
        'Angular': /ng-version/i,
        'jQuery': /jquery/i,
        'Bootstrap': /bootstrap/i,
        'PHP': /\.php/i,
        'ASP.NET': /asp\.net/i,
      };

      for (const [tech, pattern] of Object.entries(techPatterns)) {
        if (pattern.test(body)) {
          report.technologies.push({
            name: tech,
            category: 'Framework/Library',
          });
        }
      }

      console.log(`[VULN SCANNER] Detected ${report.technologies.length} technologies`);
    } catch (error) {
      console.warn(`[VULN SCANNER] Technology detection failed:`, error.message);
    }
  }

  private async checkSSL(target: string, report: VulnerabilityReport): Promise<void> {
    try {
      console.log(`[VULN SCANNER] Checking SSL/TLS...`);

      const hostname = this.extractHostname(target);

      // Essayer une connexion HTTPS
      const sslInfo = await this.getSSLInfo(hostname);

      if (sslInfo) {
        report.ssl.enabled = true;
        report.ssl.version = sslInfo.version;
        report.ssl.issuer = sslInfo.issuer;
        report.ssl.validUntil = sslInfo.validUntil;

        // V√©rifier l'expiration
        const expiryDate = new Date(sslInfo.validUntil);
        const daysUntilExpiry = Math.floor((expiryDate.getTime() - Date.now()) / (1000 * 60 * 60 * 24));

        if (daysUntilExpiry < 0) {
          report.ssl.issues.push('Certificat expir√©');
          report.vulnerabilities.push({
            id: 'SSL_EXPIRED',
            title: 'Certificat SSL expir√©',
            severity: 'critical',
            description: 'Le certificat SSL/TLS a expir√©.',
            recommendation: 'Renouveler imm√©diatement le certificat SSL.',
          });
        } else if (daysUntilExpiry < 30) {
          report.ssl.issues.push(`Certificat expire dans ${daysUntilExpiry} jours`);
        }
      } else {
        report.ssl.enabled = false;
        report.vulnerabilities.push({
          id: 'NO_SSL',
          title: 'SSL/TLS non activ√©',
          severity: 'high',
          description: 'Le site n\'utilise pas HTTPS, les donn√©es sont transmises en clair.',
          recommendation: 'Activer SSL/TLS avec un certificat valide (Let\'s Encrypt gratuit).',
        });
      }

      console.log(`[VULN SCANNER] SSL check complete`);
    } catch (error) {
      console.warn(`[VULN SCANNER] SSL check failed:`, error.message);
    }
  }

  private async checkCommonVulnerabilities(report: VulnerabilityReport): Promise<void> {
    console.log(`[VULN SCANNER] Checking common vulnerabilities...`);

    // Vuln√©rabilit√©s bas√©es sur les ports ouverts
    for (const port of report.openPorts) {
      if (port.port === 21 && port.risk === 'high') {
        report.vulnerabilities.push({
          id: 'FTP_EXPOSED',
          title: 'Port FTP expos√©',
          severity: 'high',
          description: 'Le port FTP (21) est ouvert et accessible, ce qui peut permettre des attaques par force brute.',
          recommendation: 'D√©sactiver FTP et utiliser SFTP/SCP √† la place.',
        });
      }

      if (port.port === 23) {
        report.vulnerabilities.push({
          id: 'TELNET_EXPOSED',
          title: 'Telnet actif (CRITIQUE)',
          severity: 'critical',
          description: 'Telnet transmet les credentials en clair sur le r√©seau.',
          recommendation: 'D√©sactiver Telnet imm√©diatement et utiliser SSH.',
        });
      }

      if (port.port === 3306 && port.risk === 'high') {
        report.vulnerabilities.push({
          id: 'MYSQL_EXPOSED',
          title: 'Base de donn√©es MySQL expos√©e',
          severity: 'high',
          description: 'MySQL est accessible depuis Internet, exposant √† des attaques.',
          recommendation: 'Restreindre l\'acc√®s MySQL aux IPs autoris√©es uniquement.',
        });
      }

      if (port.port === 3389) {
        report.vulnerabilities.push({
          id: 'RDP_EXPOSED',
          title: 'RDP expos√© sur Internet',
          severity: 'critical',
          description: 'Le bureau √† distance (RDP) est accessible, cible privil√©gi√©e des ransomwares.',
          recommendation: 'Utiliser un VPN et MFA pour acc√©der √† RDP.',
          cve: 'CVE-2019-0708', // BlueKeep
        });
      }
    }

    // Vuln√©rabilit√©s bas√©es sur les technologies
    for (const tech of report.technologies) {
      if (tech.name.toLowerCase().includes('wordpress')) {
        report.vulnerabilities.push({
          id: 'WORDPRESS_DETECTED',
          title: 'WordPress d√©tect√©',
          severity: 'medium',
          description: 'WordPress est une cible fr√©quente. Version et plugins doivent √™tre √† jour.',
          recommendation: 'Maintenir WordPress, th√®mes et plugins √† jour. Utiliser un WAF.',
        });
      }
    }
  }

  private calculateRiskLevel(report: VulnerabilityReport): void {
    let score = 100;

    // P√©nalit√©s pour vuln√©rabilit√©s
    for (const vuln of report.vulnerabilities) {
      switch (vuln.severity) {
        case 'critical':
          score -= 25;
          break;
        case 'high':
          score -= 15;
          break;
        case 'medium':
          score -= 8;
          break;
        case 'low':
          score -= 3;
          break;
      }
    }

    // Bonus pour headers de s√©curit√©
    score += (report.securityHeaders.score / 100) * 10;

    // Bonus pour SSL
    if (report.ssl.enabled && report.ssl.issues.length === 0) {
      score += 10;
    }

    report.overallScore = Math.max(0, Math.min(100, Math.round(score)));

    // D√©terminer le niveau de risque
    if (report.overallScore >= 80) {
      report.riskLevel = 'low';
    } else if (report.overallScore >= 60) {
      report.riskLevel = 'medium';
    } else if (report.overallScore >= 40) {
      report.riskLevel = 'high';
    } else {
      report.riskLevel = 'critical';
    }

    console.log(`[VULN SCANNER] Risk Level: ${report.riskLevel} (Score: ${report.overallScore}/100)`);
  }

  private generateRecommendations(report: VulnerabilityReport): void {
    // Recommandations prioritaires
    if (!report.ssl.enabled) {
      report.recommendations.push('üîí Activer HTTPS avec un certificat SSL valide');
    }

    if (report.securityHeaders.score < 70) {
      report.recommendations.push('üõ°Ô∏è Impl√©menter les headers de s√©curit√© HTTP manquants');
    }

    if (report.openPorts.some(p => p.risk === 'high')) {
      report.recommendations.push('üî• Fermer les ports sensibles expos√©s inutilement');
    }

    if (report.vulnerabilities.some(v => v.severity === 'critical')) {
      report.recommendations.push('‚ö†Ô∏è Corriger les vuln√©rabilit√©s critiques en priorit√© absolue');
    }

    // Recommandations g√©n√©rales
    report.recommendations.push('üìä Mettre en place un monitoring de s√©curit√© 24/7');
    report.recommendations.push('üîÑ Maintenir tous les logiciels √† jour');
    report.recommendations.push('üë• Former les √©quipes √† la cybers√©curit√©');
  }

  // Utilitaires
  private extractHostname(target: string): string {
    try {
      if (target.startsWith('http')) {
        const url = new URL(target);
        return url.hostname;
      }
      return target.replace(/^www\./, '');
    } catch {
      return target;
    }
  }

  private fetchHeaders(url: string): Promise<Record<string, string>> {
    return new Promise((resolve, reject) => {
      const client = url.startsWith('https') ? https : http;

      const req = client.get(url, { timeout: 10000 }, (res) => {
        const headers: Record<string, string> = {};
        for (const [key, value] of Object.entries(res.headers)) {
          if (typeof value === 'string') {
            headers[key.toLowerCase()] = value;
          }
        }
        resolve(headers);
        req.destroy();
      });

      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Request timeout'));
      });
    });
  }

  private fetchPage(url: string): Promise<{ body: string; headers: Record<string, string> }> {
    return new Promise((resolve, reject) => {
      const client = url.startsWith('https') ? https : http;

      const req = client.get(url, { timeout: 10000 }, (res) => {
        let body = '';
        const headers: Record<string, string> = {};

        for (const [key, value] of Object.entries(res.headers)) {
          if (typeof value === 'string') {
            headers[key.toLowerCase()] = value;
          }
        }

        res.on('data', (chunk) => {
          body += chunk.toString();
          // Limiter √† 1MB
          if (body.length > 1024 * 1024) {
            req.destroy();
          }
        });

        res.on('end', () => {
          resolve({ body, headers });
        });
      });

      req.on('error', reject);
      req.on('timeout', () => {
        req.destroy();
        reject(new Error('Request timeout'));
      });
    });
  }

  private getSSLInfo(hostname: string): Promise<any> {
    return new Promise((resolve) => {
      const req = https.get(`https://${hostname}`, { timeout: 10000 }, (res) => {
        const cert = (res.socket as any).getPeerCertificate();

        if (cert && Object.keys(cert).length > 0) {
          resolve({
            version: (res.socket as any).getProtocol(),
            issuer: cert.issuer?.O || 'Unknown',
            validUntil: cert.valid_to,
          });
        } else {
          resolve(null);
        }

        req.destroy();
      });

      req.on('error', () => resolve(null));
      req.on('timeout', () => {
        req.destroy();
        resolve(null);
      });
    });
  }
}
